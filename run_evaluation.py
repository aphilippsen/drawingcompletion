import numpy as np
import os
import matplotlib.pyplot as plt
import pathlib

#data_set_name = 'example'
data_set_name = "final_0.01-100_6x7"#"tmpComp1000"#-training-set" #"training-2020-02-new-completion" # "tmp"#"training-2020-03_noise0.01"#test-set"
#data_set_name = "2019-11-all-test-set"

# Evaluation of the inference results
# when train and test hyp-prior vary!

# data for plotting the correct trajectories
training_data_file = "data_generation/drawing-data-sets/drawings-191105-6x3-test.npy"#data_generation/drawing-data-sets/drawings-191105-6-drawings.npy"
x_train = np.float32(np.load(training_data_file))

eval_head_dir = './results/completion/' + data_set_name
mode = 'inference'
# mode = 'best'

# which testing H to check
test_hyp_all = ['0.001', '0.01', '0.1', '1', '10', '100', '1000'] 
#test_hyp_all = ['0.001', '0.01', '0.1', '1', '1', '1', '1']

num_runs = 10 # how often the experiment was independently conducted
num_inferences = 3 # how many test inferences have been performed in each run
num_patterns = 6 # number of different training sample patterns

dir_list = next(os.walk(eval_head_dir))[1]

# sanity check
assert(num_inferences*num_patterns == x_train.shape[0])
assert(len(dir_list) == num_runs)

# Which training H to use. If 'corresponding, use the same training = test H
training_hyp = 'corresponding'

# this code is only for one value reduced_time_steps at a time! (by default that means, 30 timesteps are visible)
reduced = 0 # index which array entry to read

# create data structures for storing all data generated by one training_hyp
best_vis = np.empty((len(test_hyp_all), 1), dtype=object)
best_new = np.empty((len(test_hyp_all), 1), dtype=object)
corr_vis = np.empty((len(test_hyp_all), 1), dtype=object)
corr_new = np.empty((len(test_hyp_all), 1), dtype=object)

results = np.empty((len(test_hyp_all), 1), dtype=object)

plot_dir = "./results/evaluation/" + data_set_name + '/' + mode + '-' + training_hyp
pathlib.Path(plot_dir).mkdir(parents=True, exist_ok=True)

# Iterate across the testing hyp conditions
test_hyp_idx = -1
for test_hyp in test_hyp_all:
    test_hyp_idx += 1

    # initialize arrays for this test_hyp
    best_vis[test_hyp_idx,0] = np.zeros((num_runs*num_inferences, num_patterns))
    best_new[test_hyp_idx,0] = np.zeros((num_runs*num_inferences, num_patterns))
    corr_vis[test_hyp_idx,0] = np.zeros((num_runs*num_inferences, num_patterns))
    corr_new[test_hyp_idx,0] = np.zeros((num_runs*num_inferences, num_patterns))

    results[test_hyp_idx,0] = np.empty((num_runs*num_inferences, num_patterns), dtype=object)

    run_idx = 0-num_inferences
    for curr_r in range(len(dir_list)):
        run_idx += num_inferences
        print("Current run index: " + str(run_idx))
        current_run = os.path.join(eval_head_dir, dir_list[curr_r])
        if training_hyp == 'corresponding':
            train_hyp_dir = test_hyp
        else:
            train_hyp_dir = training_hyp

        eval_dir = current_run+'/'+train_hyp_dir+'/'+mode+'/test-'+test_hyp

        # load precomputed errors
        err_best_vis = np.load(os.path.join(eval_dir, 'final-err_vis_best-' + str(test_hyp) + '_mode-' + mode + '.npy'))
        err_best_new = np.load(os.path.join(eval_dir, 'final-err_new_best-' + str(test_hyp) + '_mode-' + mode + '.npy'))
        err_corr_vis = np.load(os.path.join(eval_dir, 'final-err_vis_corr-' + str(test_hyp) + '_mode-' + mode + '.npy'))
        err_corr_new = np.load(os.path.join(eval_dir, 'final-err_new_corr-' + str(test_hyp) + '_mode-' + mode + '.npy'))
        current_results = np.load(os.path.join(eval_dir, 'final-res_hyp-' + str(test_hyp) + '_mode-' + mode + '.npy'))
        # each contains [num_images x 1], [num_inferences]

        # copy the errors of this run into the data structure
        best_vis[test_hyp_idx,0][run_idx:run_idx+num_inferences,:] = np.transpose(np.resize(np.concatenate((np.array(err_best_vis[0][0]), np.array(err_best_vis[1][0]), np.array(err_best_vis[2][0]), np.array(err_best_vis[3][0]), np.array(err_best_vis[4][0]), np.array(err_best_vis[5][0]))), (num_patterns,num_inferences)))
        best_new[test_hyp_idx,0][run_idx:run_idx+num_inferences,:] = np.transpose(np.resize(np.concatenate((np.array(err_best_new[0][0]), np.array(err_best_new[1][0]), np.array(err_best_new[2][0]), np.array(err_best_new[3][0]), np.array(err_best_new[4][0]), np.array(err_best_new[5][0]))), (num_patterns,num_inferences)))

        corr_vis[test_hyp_idx,0][run_idx:run_idx+num_inferences,:] = np.transpose(np.resize(np.concatenate((np.array(err_corr_vis[0][0]), np.array(err_corr_vis[1][0]), np.array(err_corr_vis[2][0]), np.array(err_corr_vis[3][0]), np.array(err_corr_vis[4][0]), np.array(err_corr_vis[5][0]))), (num_patterns,num_inferences)))
        corr_new[test_hyp_idx,0][run_idx:run_idx+num_inferences,:] = np.transpose(np.resize(np.concatenate((np.array(err_corr_new[0][0]), np.array(err_corr_new[1][0]), np.array(err_corr_new[2][0]), np.array(err_corr_new[3][0]), np.array(err_corr_new[4][0]), np.array(err_corr_new[5][0]))), (num_patterns,num_inferences)))

        for pat in range(num_patterns):
            results[test_hyp_idx,0][run_idx:run_idx+num_inferences,pat] = current_results[pat][0]


# compute means and std for all the test_hyp conditions

# number of test_hyp conditions
num_test_hyp = best_vis.shape[0]

best_vis_means = np.zeros((num_test_hyp, num_patterns))
best_vis_std = np.zeros((num_test_hyp, num_patterns))
best_new_means = np.zeros((num_test_hyp, num_patterns))
best_new_std = np.zeros((num_test_hyp, num_patterns))

corr_vis_means = np.zeros((num_test_hyp, num_patterns))
corr_vis_std = np.zeros((num_test_hyp, num_patterns))
corr_new_means = np.zeros((num_test_hyp, num_patterns))
corr_new_std = np.zeros((num_test_hyp, num_patterns))

for num_t in range(num_test_hyp):
    best_vis_means[num_t,:] = np.mean(best_vis[num_t,0],axis=0)
    best_vis_std[num_t,:] = np.std(best_vis[num_t,0],axis=0)
    best_new_means[num_t,:] = np.mean(best_new[num_t,0],axis=0)
    best_new_std[num_t,:] = np.std(best_new[num_t,0],axis=0)

    corr_vis_means[num_t,:] = np.mean(corr_vis[num_t,0],axis=0)
    corr_vis_std[num_t,:] = np.std(corr_vis[num_t,0],axis=0)
    corr_new_means[num_t,:] = np.mean(corr_new[num_t,0],axis=0)
    corr_new_std[num_t,:] = np.std(corr_new[num_t,0],axis=0)

# write info to a csv for statistics analysis
import pandas as pd
error_data_summary = []
test_hyp_idx = -1
for test_hyp in test_hyp_all:
    test_hyp_idx += 1

    for r in range(num_runs):
        for inf in range(num_inferences):
            for pat in range(num_patterns):
                error_data_summary.append([test_hyp, r, inf, pat, best_new[test_hyp_idx][0][r*num_inferences+inf, pat], best_vis[test_hyp_idx][0][r*num_inferences+inf, pat]])
                
    
df_error_data = pd.DataFrame(data=error_data_summary, columns = ['H', 'netId', 'infId', 'pattern', 'errNewBest', 'errVisBest'])
df_error_data.to_csv(os.path.join(plot_dir, "error_data_summary.csv"))


# confusions

"""
# doesn't properly work

confu_mean = np.zeros(num_test_hyp)
confu_std = np.zeros(num_test_hyp)
threshold = 0.005
for i in range(num_test_hyp):
    confu_mean[i] = np.mean((corr_new[i,0][best_new[i,0]<threshold] - best_new[i,0][best_new[i,0]<threshold]))
    confu_std[i] = np.std((corr_new[i,0][best_new[i,0]<threshold] - best_new[i,0][best_new[i,0]<threshold]))

colors = ['blue', 'purple', 'turquoise', 'green', 'red', 'orange', 'pink']

plt.figure()

for i in range(num_test_hyp):
    plt.plot(np.arange(7), confu_mean)

plt.errorbar(np.arange(7), confu_mean, yerr=confu_std)
"""

confusions = np.zeros(num_test_hyp)
correct_class = np.zeros(num_test_hyp)
for i in range(num_test_hyp):
    # confusions[i] = (np.count_nonzero((best_new[i,0]-corr_new[i,0])==0))
    # confusions[i] = np.count_nonzero(((best_new[i,0]-corr_new[i,0])==0) & (best_new[i,0]<0.01))

    # count how many were NOT correctly classified (the "best" error measure equals the "corresponding")
    confusions[i] = np.count_nonzero(((best_new[i,0]-corr_new[i,0])!=0))
    # count how many were correctly classified
    correct_class[i] = np.count_nonzero(((best_new[i,0]-corr_new[i,0])==0))


# percentage
num_pics = best_new[0,0].shape[0] * best_new[0,0].shape[1]
confusions = confusions/num_pics*100
correct_class = correct_class/num_pics*100

######################################
# Final statistics plot              #
######################################

# in a single window with different colors for the patterns
output_format = "pdf"
# prepare the positions on the x axis
# x = [0, 1, 2, 3, 4]

# for three patterns
# x = [[0.3, 2.3, 4.3, 6.3, 8.3], [0.5, 2.5, 4.5, 6.5, 8.5], [0.7, 2.7, 4.7, 6.7, 8.7]]
# colors = ['red', 'blue', 'green']
# pattern_category = ['FACE', 'HOUSE', 'FLOWER']

# for six patterns
# x = [[0.05, 2.05, 4.05, 6.05, 8.05], [0.3, 2.3, 4.3, 6.3, 8.3], [0.55, 2.55, 4.55, 6.55, 8.55], [0.8, 2.8, 4.8, 6.8, 8.8], [1.05, 3.05, 5.05, 7.05, 9.05], [1.3, 3.3, 5.3, 7.3, 9.3]]
# for six pattern and 7 conditions
x = [[0.05, 2.05, 4.05, 6.05, 8.05, 10.05, 12.05], [0.3, 2.3, 4.3, 6.3, 8.3, 10.3, 12.3], [0.55, 2.55, 4.55, 6.55, 8.55, 10.55, 12.55], [0.8, 2.8, 4.8, 6.8, 8.8, 10.8, 12.8], [1.05, 3.05, 5.05, 7.05, 9.05, 11.05, 13.05], [1.3, 3.3, 5.3, 7.3, 9.3, 11.3, 13.3]]
colors = ['red', 'orange', 'green', 'blue', 'gray', 'black']
pattern_category = ['FACE', 'HOUSE', 'CAR', 'FLOWER', 'HUMAN', 'ROCKET']

max_lim = 0.5
# which labels to put to these positions
my_xticks = []
for num_t in range(num_test_hyp):
    my_xticks.append('H=' + str(test_hyp_all[num_t]))

orientation_y_line = np.tile(0.005, (2,)) # np.max(vis_corr[1])

# separate drawings for each pattern
fig = plt.figure('New_best', figsize=(35.0, 12.0))
plt.rcParams.update({'font.size': 50, 'legend.fontsize': 40})
ax = fig.add_subplot(111)
ax.set_xlabel('prior parameter condition')
ax.set_ylabel('Drawing error (DTW distance)')

for line_offset in np.arange(-0.005, max_lim, 0.05):
    plt.plot([-1, 16], orientation_y_line+line_offset, 'lightgray', zorder=0, linewidth=5)

for pat in range(num_patterns):
    for bla in range(len(x[pat])):

        median_value = np.percentile(best_new[bla][0][:,pat], 50)
        upper_quantile = np.percentile(best_new[bla][0][:,pat], 90)
        lower_quantile = np.percentile(best_new[bla][0][:,pat], 10)
        lower_std_dev = np.mean(best_new[bla][0][:,pat]) - np.sqrt(np.var(best_new[bla][0][:,pat]))
        upper_std_dev = np.mean(best_new[bla][0][:,pat]) + np.sqrt(np.var(best_new[bla][0][:,pat]))

        ax.boxplot([lower_std_dev, lower_quantile, median_value, upper_quantile, upper_std_dev], positions=[x[pat][bla]], widths=[0.2], boxprops=dict(color=colors[pat],linewidth=5), medianprops=dict(color=colors[pat], linewidth=5), flierprops=dict(color=colors[pat], linewidth=5), whiskerprops=dict(color=colors[pat], linewidth=5), capprops=dict(color=colors[pat], linewidth=5), showfliers=False)

        if bla == 0:
            ax.scatter(np.repeat(x[pat][bla], len(best_new[bla][0][:,pat])), best_new[bla][0][:,pat], color=colors[pat], label=pattern_category[pat], s=100,marker='o')
        else:
            ax.scatter(np.repeat(x[pat][bla], len(best_new[bla][0][:,pat])), best_new[bla][0][:,pat], color=colors[pat], s=100,marker='o')


#        ax.scatter(x[pat][bla], median_best_new, color=colors[pat], marker='s', s=1000)
#        ax.scatter(x[pat][bla], upper_best_new, color=colors[pat], marker='s', s=1000)
#        ax.scatter(x[pat][bla], lower_best_new, color=colors[pat], marker='s', s=1000)

    # ax.errorbar(x[pat], best_new_means[:,pat], yerr=best_new_std[:,pat], color=colors[pat], ecolor=colors[pat], fmt='o', markersize=20, capsize=15, capthick=5, elinewidth=5, barsabove=True, label=pattern_category[pat])

plt.xticks(x[2], my_xticks)
ax.set_xlim([-0.2, 15.8])
ax.set_ylim([-0.002, max_lim])
fig.legend(loc=(0.855, 0.47))
fig.tight_layout()
plt.savefig(os.path.join(plot_dir, 'completion_new-part_best.' + output_format))
plt.close()

fig = plt.figure('New_corr', figsize=(35.0, 12.0))
plt.rcParams.update({'font.size': 50, 'legend.fontsize': 40})
ax = fig.add_subplot(111)
ax.set_xlabel('prior parameter condition')
ax.set_ylabel('Drawing error (DTW distance)')

for line_offset in np.arange(-0.005, max_lim, 0.05):
    plt.plot([-1, 16], orientation_y_line+line_offset, 'lightgray', zorder=0, linewidth=5)

for pat in range(num_patterns):
    for bla in range(len(x[pat])):

        median_value = np.percentile(corr_new[bla][0][:,pat], 50)
        upper_quantile = np.percentile(corr_new[bla][0][:,pat], 90)
        lower_quantile = np.percentile(corr_new[bla][0][:,pat], 10)
        lower_std_dev = np.mean(corr_new[bla][0][:,pat]) - np.sqrt(np.var(corr_new[bla][0][:,pat]))
        upper_std_dev = np.mean(corr_new[bla][0][:,pat]) + np.sqrt(np.var(corr_new[bla][0][:,pat]))

        ax.boxplot([lower_std_dev, lower_quantile, median_value, upper_quantile, upper_std_dev], positions=[x[pat][bla]], widths=[0.2], boxprops=dict(color=colors[pat],linewidth=5), medianprops=dict(color=colors[pat], linewidth=5), flierprops=dict(color=colors[pat], linewidth=5), whiskerprops=dict(color=colors[pat], linewidth=5), capprops=dict(color=colors[pat], linewidth=5), showfliers=False)


        if bla == 0:
            ax.scatter(np.repeat(x[pat][bla], len(corr_new[bla][0][:,pat])), corr_new[bla][0][:,pat], color=colors[pat], label=pattern_category[pat], s=100,marker='o')
        else:
            ax.scatter(np.repeat(x[pat][bla], len(corr_new[bla][0][:,pat])), corr_new[bla][0][:,pat], color=colors[pat], s=100, marker='o')
    # ax.errorbar(x[pat], corr_new_means[:,pat], yerr=corr_new_std[:,pat], color=colors[pat], ecolor=colors[pat], fmt='o', markersize=20, capsize=10, capthick=5, elinewidth=5, barsabove=True, label=pattern_category[pat])
plt.xticks(x[2], my_xticks)
ax.set_xlim([-0.2, 15.8])
ax.set_ylim([-0.002, max_lim])
fig.legend(loc=(0.855, 0.47))
fig.tight_layout()
plt.savefig(os.path.join(plot_dir,'completion_new-part_correct.' + output_format))
plt.close()

fig = plt.figure('vis_best', figsize=(35.0, 12.0))
plt.rcParams.update({'font.size': 50, 'legend.fontsize': 40})
ax = fig.add_subplot(111)
ax.set_xlabel('prior parameter condition')
ax.set_ylabel('Drawing error (DTW distance)')

for line_offset in np.arange(-0.005, max_lim, 0.05):
    plt.plot([-1, 16], orientation_y_line+line_offset, 'lightgray', zorder=0, linewidth=5)

for pat in range(num_patterns):
    for bla in range(len(x[pat])):

        median_value = np.percentile(best_vis[bla][0][:,pat], 50)
        upper_quantile = np.percentile(best_vis[bla][0][:,pat], 90)
        lower_quantile = np.percentile(best_vis[bla][0][:,pat], 10)
        lower_std_dev = np.mean(best_vis[bla][0][:,pat]) - np.sqrt(np.var(best_vis[bla][0][:,pat]))
        upper_std_dev = np.mean(best_vis[bla][0][:,pat]) + np.sqrt(np.var(best_vis[bla][0][:,pat]))

        ax.boxplot([lower_std_dev, lower_quantile, median_value, upper_quantile, upper_std_dev], positions=[x[pat][bla]], widths=[0.2], boxprops=dict(color=colors[pat],linewidth=5), medianprops=dict(color=colors[pat], linewidth=5), flierprops=dict(color=colors[pat], linewidth=5), whiskerprops=dict(color=colors[pat], linewidth=5), capprops=dict(color=colors[pat], linewidth=5), showfliers=False)

        if bla == 0:
            ax.scatter(np.repeat(x[pat][bla], len(best_vis[bla][0][:,pat])), best_vis[bla][0][:,pat], color=colors[pat], label=pattern_category[pat], s=100,marker='o')
        else:
            ax.scatter(np.repeat(x[pat][bla], len(best_vis[bla][0][:,pat])), best_vis[bla][0][:,pat], color=colors[pat], s=100,marker='o')
    # ax.errorbar(x[pat], best_vis_means[:,pat], yerr=best_vis_std[:,pat], color=colors[pat], ecolor=colors[pat], fmt='o', markersize=20, capsize=15, capthick=5, elinewidth=5, barsabove=True, label=pattern_category[pat])
plt.xticks(x[2], my_xticks)
ax.set_xlim([-0.2, 15.8])
ax.set_ylim([-0.002, max_lim])
fig.legend(loc=(0.855, 0.47))
fig.tight_layout()
plt.savefig(os.path.join(plot_dir,'completion_visible-part_best.' + output_format))
plt.close()

fig = plt.figure('vis_corr', figsize=(35.0, 12.0))
plt.rcParams.update({'font.size': 50, 'legend.fontsize': 40})
ax = fig.add_subplot(111)
ax.set_xlabel('prior parameter condition')
ax.set_ylabel('Drawing error (DTW distance)')

for line_offset in np.arange(-0.005, max_lim, 0.05):
    plt.plot([-1, 16], orientation_y_line+line_offset, 'lightgray', zorder=0, linewidth=5)

for pat in range(num_patterns):
    for bla in range(len(x[pat])):

        median_value = np.percentile(corr_vis[bla][0][:,pat], 50)
        upper_quantile = np.percentile(corr_vis[bla][0][:,pat], 90)
        lower_quantile = np.percentile(corr_vis[bla][0][:,pat], 10)
        lower_std_dev = np.mean(corr_vis[bla][0][:,pat]) - np.sqrt(np.var(corr_vis[bla][0][:,pat]))
        upper_std_dev = np.mean(corr_vis[bla][0][:,pat]) + np.sqrt(np.var(corr_vis[bla][0][:,pat]))

        ax.boxplot([lower_std_dev, lower_quantile, median_value, upper_quantile, upper_std_dev], positions=[x[pat][bla]], widths=[0.2], boxprops=dict(color=colors[pat],linewidth=5), medianprops=dict(color=colors[pat], linewidth=5), flierprops=dict(color=colors[pat], linewidth=5), whiskerprops=dict(color=colors[pat], linewidth=5), capprops=dict(color=colors[pat], linewidth=5), showfliers=False)

        if bla == 0:
            ax.scatter(np.repeat(x[pat][bla], len(corr_vis[bla][0][:,pat])), corr_vis[bla][0][:,pat], color=colors[pat], label=pattern_category[pat], s=100, marker='o')
        else:
            ax.scatter(np.repeat(x[pat][bla], len(corr_vis[bla][0][:,pat])), corr_vis[bla][0][:,pat], color=colors[pat], s=100, marker='o')
    # ax.errorbar(x[pat], corr_vis_means[:,pat], yerr=corr_vis_std[:,pat], color=colors[pat], ecolor=colors[pat], fmt='o', markersize=20, capsize=10, capthick=5, elinewidth=5, barsabove=True, label=pattern_category[pat])
plt.xticks(x[2], my_xticks)
ax.set_xlim([-0.2, 15.8])
ax.set_ylim([-0.002, max_lim])
fig.legend(loc=(0.855, 0.47))
fig.tight_layout()
plt.savefig(os.path.join(plot_dir, 'completion_visible-part_correct.' + output_format))
plt.close()

#import pdb; pdb.set_trace()

######################################
# Qualitative examples plotted       #
######################################
# due to a bug (i forgot to call cuda.to_cpu before storing the results, some
# files might only be possible to open on a cuda-installed PC...


from chainer import cuda

num_timesteps = 90
input_dim = 3
given_part = 30
num_classes = 6

# plot final drawing only
fileformat = '.pdf'
# # for video animation
# traj_lengths_to_plot=[90]
# fileformat = '.png'

image_idx_start = 0 # required if different lengths should be plot for making a video
# traj_lengths_to_plot= np.concatenate((np.arange(num_timesteps), np.tile(90, (200,))))
traj_lengths_to_plot = [90]

figWidth = 15
# inf_idx = [6,7,8]
#inf_idx = [0,1,2,3,4,5,6,7,8,9]
inf_idx = list(np.arange(num_inferences))


for curr_r in range(num_runs):
    for test_hyp_condition in range(len(test_hyp_all)):

        image_idx = image_idx_start
        for l in traj_lengths_to_plot:
            fig = plt.figure('Qualitative results', figsize=(figWidth,30)) #figsize=(10, 11.0))
            plt.rcParams.update({'font.size': 35, 'legend.fontsize': 30})
            curr_subplot=0
            for pat in range(num_patterns):
                for ii in inf_idx:
                    input_traj_idx = ii*num_classes+pat
                    print(str(ii) + ", " + str(pat) + ", " + str(input_traj_idx))

                    ax = fig.add_subplot(num_patterns,len(inf_idx),1 + curr_subplot)
                    # ax.set_xlabel('$x_0$')
                    # ax.set_ylabel('$x_1$')
                    ax.set_xlim([-0.9, 0.9])
                    ax.set_ylim([-0.9, 1])
                    # if ii > 0:
                    plt.yticks([], [])
                    # if pat < 2:
                    plt.xticks([], [])

                    ax.plot(x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),0], x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),1], 'orange', linewidth = 5)
                    traj = cuda.to_cpu(results[test_hyp_condition][0][ii*num_runs+curr_r,pat].reshape((num_timesteps, input_dim)))
                    for t in range(1, l):
                        if int(np.round(traj[t,2])) == 1:
                            if t < given_part:
                                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
                            else:
                                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
                        else:
                            if t < given_part:
                                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)
                            else:
                                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
                    if ii == np.floor(num_inferences/2):
                        # in the middle put the title
                        if pat == 0:
                            plt.title('FACE')
                        elif pat == 1:
                            plt.title('HOUSE')
                        elif pat == 2:
                            plt.title('CAR')
                        elif pat == 3:
                            plt.title('FLOWER')
                        elif pat == 4:
                            plt.title('HUMAN')
                        elif pat == 5:
                            plt.title('ROCKET')

                    curr_subplot += 1
            plt.tight_layout()
            plt.savefig(os.path.join(plot_dir, 'Qualitative-' + str(test_hyp_all[test_hyp_condition]) + "_run-" + dir_list[curr_r] + "_" + str(image_idx) + fileformat))
            image_idx += 1
            plt.close()



#
# # run_idx = [6,7,8]
# # run_idx = [0,1,2,3,4,5,6,7,8,9]
# image_idx = image_idx_start
# for l in traj_lengths_to_plot:
#     fig = plt.figure('Qualitative results', figsize=(figWidth, 11))
#     plt.rcParams.update({'font.size': 35, 'legend.fontsize': 30})
#     curr_subplot=0
#     for pat in range(results_normal.shape[0]):
#         for r in range(len(run_idx)):
#             input_traj_idx = run_idx[r]*num_classes+pat
#             ax = fig.add_subplot(3, len(run_idx),1 + curr_subplot)
#             # ax.set_xlabel('$x_0$')
#             # ax.set_ylabel('$x_1$')
#             ax.set_xlim([-0.9, 0.9])
#             ax.set_ylim([-0.9, 1])
#             # if run_idx[r] > 0:
#             plt.yticks([], [])
#             # if pat < 2:
#             plt.xticks([], [])
#             ax.plot(x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),0], x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),1], 'orange', linewidth = 5)
#             traj = cuda.to_cpu(results_normal[pat][run_idx[r]].reshape((num_timesteps, input_dim)))
#             for t in range(1, l):
#                 if int(np.round(traj[t,2])) == 1:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
#                 else:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
#             if r == 1:
#                 # in the middle put the title
#                 if pat == 0:
#                     plt.title('FACE')
#                 elif pat == 1:
#                     plt.title('HOUSE')
#                 elif pat == 2:
#                     plt.title('FLOWER')
#             curr_subplot += 1
#     plt.tight_layout()
#     plt.savefig(os.path.join(plot_dir, 'Qualitative-normal_' + str(image_idx) + fileformat))
#     image_idx += 1
#     plt.close()
#
# # run_idx = [6,7,8]
# # run_idx = [0,1,2,3,4,5,6,7,8,9]
# image_idx = image_idx_start
# for l in traj_lengths_to_plot:
#     fig = plt.figure('Qualitative results', figsize=(figWidth, 11))
#     plt.rcParams.update({'font.size': 35, 'legend.fontsize': 30})
#     curr_subplot=0
#     for pat in range(results_hypo_mod.shape[0]):
#         for r in range(len(run_idx)):
#             input_traj_idx = run_idx[r]*num_classes+pat
#             ax = fig.add_subplot(3,len(run_idx),1 + curr_subplot)
#             # ax.set_xlabel('$x_0$')
#             # ax.set_ylabel('$x_1$')
#             ax.set_xlim([-0.9, 0.9])
#             ax.set_ylim([-0.9, 1])
#             # if run_idx[r] > 0:
#             plt.yticks([], [])
#             # if pat < 2:
#             plt.xticks([], [])
#             ax.plot(x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),0], x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),1], 'orange', linewidth = 5)
#             traj = cuda.to_cpu(results_hypo_mod[pat][run_idx[r]].reshape((num_timesteps, input_dim)))
#             for t in range(1, l):
#                 if int(np.round(traj[t,2])) == 1:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
#                 else:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
#             if r == 1:
#                 # in the middle put the title
#                 if pat == 0:
#                     plt.title('FACE')
#                 elif pat == 1:
#                     plt.title('HOUSE')
#                 elif pat == 2:
#                     plt.title('FLOWER')
#             curr_subplot += 1
#     plt.tight_layout()
#     plt.savefig(os.path.join(plot_dir, 'Qualitative-hypo-mod_' + str(image_idx) + fileformat))
#     image_idx += 1
#     plt.close()
#
#
# # run_idx = [6,7,8]
# # run_idx = [0,1,2,3,4,5,6,7,8,9]
# image_idx = image_idx_start
# for l in traj_lengths_to_plot:
#     fig = plt.figure('Qualitative results', figsize=(figWidth,11))
#     plt.rcParams.update({'font.size': 35, 'legend.fontsize': 30})
#     curr_subplot=0
#     for pat in range(results_hypo.shape[0]):
#         for r in range(len(run_idx)):
#             input_traj_idx = run_idx[r]*num_classes+pat
#             ax = fig.add_subplot(3,len(run_idx),1 + curr_subplot)
#             # ax.set_xlabel('$x_0$')
#             # ax.set_ylabel('$x_1$')
#             ax.set_xlim([-0.9, 0.9])
#             ax.set_ylim([-0.9, 1])
#             # if run_idx[r] > 0:
#             plt.yticks([], [])
#             # if pat < 2:
#             plt.xticks([], [])
#             ax.plot(x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),0], x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),1], 'orange', linewidth = 5)
#             traj = cuda.to_cpu(results_hypo[pat][run_idx[r]].reshape((num_timesteps, input_dim)))
#             for t in range(1, l):
#                 if int(np.round(traj[t,2])) == 1:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
#                 else:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
#             if r == 1:
#                 # in the middle put the title
#                 if pat == 0:
#                     plt.title('FACE')
#                 elif pat == 1:
#                     plt.title('HOUSE')
#                 elif pat == 2:
#                     plt.title('FLOWER')
#             curr_subplot += 1
#     plt.tight_layout()
#     plt.savefig(os.path.join(plot_dir, 'Qualitative-hypo_' + str(image_idx) + fileformat))
#     image_idx += 1
#     plt.close()
#
#
#
# # run_idx = [6,7,8]
# # run_idx = [0,1,2,3,4,5,6,7,8,9]
# image_idx = image_idx_start
# for l in traj_lengths_to_plot:
#     fig = plt.figure('Qualitative results', figsize=(figWidth,11))
#     plt.rcParams.update({'font.size': 35, 'legend.fontsize': 30})
#     curr_subplot=0
#     for pat in range(results_hypo_extr.shape[0]):
#         for r in range(len(run_idx)):
#             input_traj_idx = run_idx[r]*num_classes+pat
#             ax = fig.add_subplot(3,len(run_idx),1 + curr_subplot)
#             # ax.set_xlabel('$x_0$')
#             # ax.set_ylabel('$x_1$')
#             ax.set_xlim([-0.9, 0.9])
#             ax.set_ylim([-0.9, 1])
#             # if run_idx[r] > 0:
#             plt.yticks([], [])
#             # if pat < 2:
#             plt.xticks([], [])
#             ax.plot(x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),0], x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),1], 'orange', linewidth = 5)
#             traj = cuda.to_cpu(results_hypo_extr[pat][run_idx[r]].reshape((num_timesteps, input_dim)))
#             for t in range(1, l):
#                 if int(np.round(traj[t,2])) == 1:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
#                 else:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
#             if r == 1:
#                 # in the middle put the title
#                 if pat == 0:
#                     plt.title('FACE')
#                 elif pat == 1:
#                     plt.title('HOUSE')
#                 elif pat == 2:
#                     plt.title('FLOWER')
#             curr_subplot += 1
#     plt.tight_layout()
#     plt.savefig(os.path.join(plot_dir, 'Qualitative-hypo-extr_' + str(image_idx) + fileformat))
#     image_idx += 1
#     plt.close()


######################################
# Plot training data                 #
######################################

"""
# Plot training data
#train_data = np.load('/home/anja/github/drawingcompletion/data_generation/drawing-data-sets/drawings-191105-6x7-train.npy')
train_data = np.load('/home/anja/github/drawingcompletion/data_generation/drawing-data-sets/drawings-191105-6x3-test.npy')
num_timesteps = 90
plot_timesteps = 30
input_dim = 3
given_part = 0
num_classes = 6
format_1 = 2
format_2 = 3
# 3rd dim == 1 means that this point is connected to the previous one, dim == 0 that not!

fig = plt.figure('Original training data', figsize=(30, 17.5))
plt.rcParams.update({'font.size': 55, 'legend.fontsize': 30})
for cl in range(num_classes):
    ax = fig.add_subplot(format_1, format_2, cl+1)
    ax.set_xlabel('$x_0$')
    ax.set_ylabel('$x_1$')
    ax.set_xlim([-1, 1])
    ax.set_ylim([-1, 1])
    for i in range(cl, train_data.shape[0], num_classes):
        for t in range(1, plot_timesteps):
            traj = train_data[i,:].reshape((num_timesteps, input_dim))[0:plot_timesteps,:]
            if int(np.round(traj[t,2])) == 1:
                if t < given_part:
                    ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 0.5)
                else:
                    ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 0.5)
            else:
                if t < given_part:
                    ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 0.5)
                else:
                    ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 0.5)

    i=cl
    for t in range(1, plot_timesteps):
        traj = train_data[i,:].reshape((num_timesteps, input_dim))[0:plot_timesteps,:]
        if int(np.round(traj[t,2])) == 1:
            if t < given_part:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
            else:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
        else:
            if t < given_part:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
            else:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)

plt.tight_layout()
plt.savefig('original-training-data.pdf')
plt.close()
"""
