import numpy as np
import os
import matplotlib.pyplot as plt
import pathlib


# data_set_name = '2019-11-05'
# data_set_name = '2019-11-08'
data_set_name = '2019-11-all'

# Evaluation of the inference results
# when train and test hyp-prior vary!
#
# which conditions do I want to simulate?

training_data_file = "data/drawing-data-sets/drawings-191105-6-drawings.npy"

eval_head_dir = './results/completion/' + data_set_name
#mode = 'inference'
mode = 'best'
training_hyp = '1'
#training_hyp = 'corresponding' # use the same training = test_hyp!

# this code is only for one reduced_time_steps at a time!
reduced = 0 # which array entry to read

# create data structures for storing all data generated by one training_hyp

test_hyp_all = ['0.001', '0.01', '0.1', '1', '10', '100', '1000']

best_vis = np.empty((len(test_hyp_all), 1), dtype=object)
best_new = np.empty((len(test_hyp_all), 1), dtype=object)
corr_vis = np.empty((len(test_hyp_all), 1), dtype=object)
corr_new = np.empty((len(test_hyp_all), 1), dtype=object)

results = np.empty((len(test_hyp_all), 1), dtype=object)

plot_dir = "./results/evaluation/" + data_set_name + '/' + mode + '-' + training_hyp
pathlib.Path(plot_dir).mkdir(parents=True, exist_ok=True)

num_runs = 10 # how often the experiment was independently conducted
num_inferences = 10 # how many test inferences have been performed in each run
num_patterns = 6 # number of different training sample patterns

# to iterate across these:

test_hyp_idx = -1
for test_hyp in test_hyp_all:
    test_hyp_idx += 1

    # initialize arrays for this test_hyp
    best_vis[test_hyp_idx,0] = np.zeros((num_runs*num_inferences, num_patterns))
    best_new[test_hyp_idx,0] = np.zeros((num_runs*num_inferences, num_patterns))
    corr_vis[test_hyp_idx,0] = np.zeros((num_runs*num_inferences, num_patterns))
    corr_new[test_hyp_idx,0] = np.zeros((num_runs*num_inferences, num_patterns))

    results[test_hyp_idx,0] = np.empty((num_runs*num_inferences, num_patterns), dtype=object)

    dir_list = next(os.walk(eval_head_dir))[1]
    run_idx = 0-num_inferences
    for curr_r in range(len(dir_list)):
        run_idx += num_inferences
        print("Current run index: " + str(run_idx))
        current_run = os.path.join(eval_head_dir, dir_list[curr_r])
        if training_hyp == 'corresponding':
            train_hyp_dir = test_hyp
        else:
            train_hyp_dir = training_hyp
            
        eval_dir = current_run+'/'+train_hyp_dir+'/'+mode+'/test-'+test_hyp

        # load precomputed errors
        err_best_vis = np.load(os.path.join(eval_dir, 'final-err_vis_best-' + str(test_hyp) + '_mode-' + mode + '.npy'))
        err_best_new = np.load(os.path.join(eval_dir, 'final-err_new_best-' + str(test_hyp) + '_mode-' + mode + '.npy'))
        err_corr_vis = np.load(os.path.join(eval_dir, 'final-err_vis_corr-' + str(test_hyp) + '_mode-' + mode + '.npy'))
        err_corr_new = np.load(os.path.join(eval_dir, 'final-err_new_corr-' + str(test_hyp) + '_mode-' + mode + '.npy'))
        current_results = np.load(os.path.join(eval_dir, 'final-res_hyp-' + str(test_hyp) + '_mode-' + mode + '.npy'))
        # each contains [num_images x 1], [num_inferences]

        # copy the errors of this run into the data structure
        best_vis[test_hyp_idx,0][run_idx:run_idx+num_inferences,:] = np.transpose(np.resize(np.concatenate((np.array(err_best_vis[0][0]), np.array(err_best_vis[1][0]), np.array(err_best_vis[2][0]), np.array(err_best_vis[3][0]), np.array(err_best_vis[4][0]), np.array(err_best_vis[5][0]))), (num_patterns,10)))
        best_new[test_hyp_idx,0][run_idx:run_idx+num_inferences,:] = np.transpose(np.resize(np.concatenate((np.array(err_best_new[0][0]), np.array(err_best_new[1][0]), np.array(err_best_new[2][0]), np.array(err_best_new[3][0]), np.array(err_best_new[4][0]), np.array(err_best_new[5][0]))), (num_patterns,10)))

        corr_vis[test_hyp_idx,0][run_idx:run_idx+num_inferences,:] = np.transpose(np.resize(np.concatenate((np.array(err_corr_vis[0][0]), np.array(err_corr_vis[1][0]), np.array(err_corr_vis[2][0]), np.array(err_corr_vis[3][0]), np.array(err_corr_vis[4][0]), np.array(err_corr_vis[5][0]))), (num_patterns,10)))
        corr_new[test_hyp_idx,0][run_idx:run_idx+num_inferences,:] = np.transpose(np.resize(np.concatenate((np.array(err_corr_new[0][0]), np.array(err_corr_new[1][0]), np.array(err_corr_new[2][0]), np.array(err_corr_new[3][0]), np.array(err_corr_new[4][0]), np.array(err_corr_new[5][0]))), (num_patterns,10)))

        for pat in range(num_patterns):
            results[test_hyp_idx,0][run_idx:run_idx+num_inferences,pat] = current_results[pat][0]


# compute means and std for all the test_hyp conditions

# number of test_hyp conditions
num_test_hyp = best_vis.shape[0]

best_vis_means = np.zeros((num_test_hyp, num_patterns))
best_vis_std = np.zeros((num_test_hyp, num_patterns))
best_new_means = np.zeros((num_test_hyp, num_patterns))
best_new_std = np.zeros((num_test_hyp, num_patterns))

corr_vis_means = np.zeros((num_test_hyp, num_patterns))
corr_vis_std = np.zeros((num_test_hyp, num_patterns))
corr_new_means = np.zeros((num_test_hyp, num_patterns))
corr_new_std = np.zeros((num_test_hyp, num_patterns))

for num_t in range(num_test_hyp):
    best_vis_means[num_t,:] = np.mean(best_vis[num_t,0],axis=0)
    best_vis_std[num_t,:] = np.std(best_vis[num_t,0],axis=0)
    best_new_means[num_t,:] = np.mean(best_new[num_t,0],axis=0)
    best_new_std[num_t,:] = np.std(best_new[num_t,0],axis=0)

    corr_vis_means[num_t,:] = np.mean(corr_vis[num_t,0],axis=0)
    corr_vis_std[num_t,:] = np.std(corr_vis[num_t,0],axis=0)
    corr_new_means[num_t,:] = np.mean(corr_new[num_t,0],axis=0)
    corr_new_std[num_t,:] = np.std(corr_new[num_t,0],axis=0)



######################################
# Final statistics plot              #
######################################

# in a single window with different colors for the patterns
output_format = "pdf"
# prepare the positions on the x axis
# x = [0, 1, 2, 3, 4]

# for three patterns
# x = [[0.3, 2.3, 4.3, 6.3, 8.3], [0.5, 2.5, 4.5, 6.5, 8.5], [0.7, 2.7, 4.7, 6.7, 8.7]]
# colors = ['red', 'blue', 'green']
# pattern_category = ['FACE', 'HOUSE', 'FLOWER']

# for six patterns
x = [[0.05, 2.05, 4.05, 6.05, 8.05], [0.3, 2.3, 4.3, 6.3, 8.3], [0.55, 2.55, 4.55, 6.55, 8.55], [0.8, 2.8, 4.8, 6.8, 8.8], [1.05, 3.05, 5.05, 7.05, 9.05], [1.3, 3.3, 5.3, 7.3, 9.3]]
colors = ['red', 'orange', 'green', 'blue', 'gray', 'black']
pattern_category = ['FACE', 'HOUSE', 'CAR', 'FLOWER', 'HUMAN', 'ROCKET']

# which labels to put to these positions
my_xticks = []
for num_t in range(num_test_hyp):
    my_xticks.append('H=' + str(test_hyp_all[num_t]))


orientation_y_line = np.tile(0.005, (2,)) # np.max(vis_corr[1])

# separate drawings for each pattern
fig = plt.figure('New_best', figsize=(35.0, 12.0))
plt.rcParams.update({'font.size': 50, 'legend.fontsize': 40})
ax = fig.add_subplot(111)
ax.set_xlabel('prior parameter condition')
ax.set_ylabel('Drawing error (DTW distance)')

for line_offset in np.arange(-0.005, 0.061, 0.005):
    plt.plot([-1, 11], orientation_y_line+line_offset, 'lightgray', zorder=0, linewidth=5)

for pat in range(num_patterns):
    for bla in range(len(x[pat])):

        median_value = np.percentile(best_new[bla][0][:,pat], 50)
        upper_quantile = np.percentile(best_new[bla][0][:,pat], 90)
        lower_quantile = np.percentile(best_new[bla][0][:,pat], 10)
        lower_std_dev = np.mean(best_new[bla][0][:,pat]) - np.sqrt(np.var(best_new[bla][0][:,pat]))
        upper_std_dev = np.mean(best_new[bla][0][:,pat]) + np.sqrt(np.var(best_new[bla][0][:,pat]))

        ax.boxplot([lower_std_dev, lower_quantile, median_value, upper_quantile, upper_std_dev], positions=[x[pat][bla]], widths=[0.2], boxprops=dict(color=colors[pat],linewidth=2), medianprops=dict(color=colors[pat], linewidth=2), flierprops=dict(color=colors[pat], linewidth=2), whiskerprops=dict(color=colors[pat], linewidth=2), capprops=dict(color=colors[pat], linewidth=2), showfliers=False)

        if bla == 0:
            ax.scatter(np.repeat(x[pat][bla], len(best_new[bla][0][:,pat])), best_new[bla][0][:,pat], linewidth=2, color=colors[pat], label=pattern_category[pat])
        else:
            ax.scatter(np.repeat(x[pat][bla], len(best_new[bla][0][:,pat])), best_new[bla][0][:,pat], linewidth=2, color=colors[pat])


#        ax.scatter(x[pat][bla], median_best_new, color=colors[pat], marker='s', s=1000)
#        ax.scatter(x[pat][bla], upper_best_new, color=colors[pat], marker='s', s=1000)
#        ax.scatter(x[pat][bla], lower_best_new, color=colors[pat], marker='s', s=1000)

    # ax.errorbar(x[pat], best_new_means[:,pat], yerr=best_new_std[:,pat], color=colors[pat], ecolor=colors[pat], fmt='o', markersize=20, capsize=15, capthick=5, elinewidth=5, barsabove=True, label=pattern_category[pat])

plt.xticks(x[2], my_xticks)
ax.set_xlim([-0.2, 11.0])
ax.set_ylim([-0.002, 0.05])
fig.legend(loc=(0.855, 0.47))
fig.tight_layout()
plt.savefig(os.path.join(plot_dir, 'completion_new-part_best.' + output_format))
plt.close()

fig = plt.figure('New_corr', figsize=(35.0, 12.0))
plt.rcParams.update({'font.size': 50, 'legend.fontsize': 40})
ax = fig.add_subplot(111)
ax.set_xlabel('prior parameter condition')
ax.set_ylabel('Drawing error (DTW distance)')

for line_offset in np.arange(-0.005, 0.061, 0.005):
    plt.plot([-1, 11], orientation_y_line+line_offset, 'lightgray', zorder=0, linewidth=5)
for pat in range(num_patterns):
    for bla in range(len(x[pat])):

        median_value = np.percentile(corr_new[bla][0][:,pat], 50)
        upper_quantile = np.percentile(corr_new[bla][0][:,pat], 90)
        lower_quantile = np.percentile(corr_new[bla][0][:,pat], 10)
        lower_std_dev = np.mean(corr_new[bla][0][:,pat]) - np.sqrt(np.var(corr_new[bla][0][:,pat]))
        upper_std_dev = np.mean(corr_new[bla][0][:,pat]) + np.sqrt(np.var(corr_new[bla][0][:,pat]))

        ax.boxplot([lower_std_dev, lower_quantile, median_value, upper_quantile, upper_std_dev], positions=[x[pat][bla]], widths=[0.2], boxprops=dict(color=colors[pat],linewidth=2), medianprops=dict(color=colors[pat], linewidth=2), flierprops=dict(color=colors[pat], linewidth=2), whiskerprops=dict(color=colors[pat], linewidth=2), capprops=dict(color=colors[pat], linewidth=2), showfliers=False)


        if bla == 0:
            ax.scatter(np.repeat(x[pat][bla], len(corr_new[bla][0][:,pat])), corr_new[bla][0][:,pat], color=colors[pat], label=pattern_category[pat])
        else:
            ax.scatter(np.repeat(x[pat][bla], len(corr_new[bla][0][:,pat])), corr_new[bla][0][:,pat], color=colors[pat])
    # ax.errorbar(x[pat], corr_new_means[:,pat], yerr=corr_new_std[:,pat], color=colors[pat], ecolor=colors[pat], fmt='o', markersize=20, capsize=10, capthick=5, elinewidth=5, barsabove=True, label=pattern_category[pat])
plt.xticks(x[2], my_xticks)
ax.set_xlim([-0.2, 11.0])
ax.set_ylim([-0.002, 0.05])
fig.legend(loc=(0.855, 0.47))
fig.tight_layout()
plt.savefig(os.path.join(plot_dir,'completion_new-part_correct.' + output_format))
plt.close()

fig = plt.figure('vis_best', figsize=(35.0, 12.0))
plt.rcParams.update({'font.size': 50, 'legend.fontsize': 40})
ax = fig.add_subplot(111)
ax.set_xlabel('prior parameter condition')
ax.set_ylabel('Drawing error (DTW distance)')

for line_offset in np.arange(-0.005, 0.061, 0.005):
    plt.plot([-1, 11], orientation_y_line+line_offset, 'lightgray', zorder=0, linewidth=5)

for pat in range(num_patterns):
    for bla in range(len(x[pat])):

        median_value = np.percentile(best_vis[bla][0][:,pat], 50)
        upper_quantile = np.percentile(best_vis[bla][0][:,pat], 90)
        lower_quantile = np.percentile(best_vis[bla][0][:,pat], 10)
        lower_std_dev = np.mean(best_vis[bla][0][:,pat]) - np.sqrt(np.var(best_vis[bla][0][:,pat]))
        upper_std_dev = np.mean(best_vis[bla][0][:,pat]) + np.sqrt(np.var(best_vis[bla][0][:,pat]))

        ax.boxplot([lower_std_dev, lower_quantile, median_value, upper_quantile, upper_std_dev], positions=[x[pat][bla]], widths=[0.2], boxprops=dict(color=colors[pat],linewidth=2), medianprops=dict(color=colors[pat], linewidth=2), flierprops=dict(color=colors[pat], linewidth=2), whiskerprops=dict(color=colors[pat], linewidth=2), capprops=dict(color=colors[pat], linewidth=2), showfliers=False)

        if bla == 0:
            ax.scatter(np.repeat(x[pat][bla], len(best_vis[bla][0][:,pat])), best_vis[bla][0][:,pat], color=colors[pat], label=pattern_category[pat])
        else:
            ax.scatter(np.repeat(x[pat][bla], len(best_vis[bla][0][:,pat])), best_vis[bla][0][:,pat], color=colors[pat])
    # ax.errorbar(x[pat], best_vis_means[:,pat], yerr=best_vis_std[:,pat], color=colors[pat], ecolor=colors[pat], fmt='o', markersize=20, capsize=15, capthick=5, elinewidth=5, barsabove=True, label=pattern_category[pat])
plt.xticks(x[2], my_xticks)
ax.set_xlim([-0.2, 11.0])
ax.set_ylim([-0.002, 0.05])
fig.legend(loc=(0.855, 0.47))
fig.tight_layout()
plt.savefig(os.path.join(plot_dir,'completion_visible-part_best.' + output_format))
plt.close()

fig = plt.figure('vis_corr', figsize=(35.0, 12.0))
plt.rcParams.update({'font.size': 50, 'legend.fontsize': 40})
ax = fig.add_subplot(111)
ax.set_xlabel('prior parameter condition')
ax.set_ylabel('Drawing error (DTW distance)')

for line_offset in np.arange(-0.005, 0.061, 0.005):
    plt.plot([-1, 11], orientation_y_line+line_offset, 'lightgray', zorder=0, linewidth=5)

for pat in range(num_patterns):
    for bla in range(len(x[pat])):

        median_value = np.percentile(corr_vis[bla][0][:,pat], 50)
        upper_quantile = np.percentile(corr_vis[bla][0][:,pat], 90)
        lower_quantile = np.percentile(corr_vis[bla][0][:,pat], 10)
        lower_std_dev = np.mean(corr_vis[bla][0][:,pat]) - np.sqrt(np.var(corr_vis[bla][0][:,pat]))
        upper_std_dev = np.mean(corr_vis[bla][0][:,pat]) + np.sqrt(np.var(corr_vis[bla][0][:,pat]))

        ax.boxplot([lower_std_dev, lower_quantile, median_value, upper_quantile, upper_std_dev], positions=[x[pat][bla]], widths=[0.2], boxprops=dict(color=colors[pat],linewidth=2), medianprops=dict(color=colors[pat], linewidth=2), flierprops=dict(color=colors[pat], linewidth=2), whiskerprops=dict(color=colors[pat], linewidth=2), capprops=dict(color=colors[pat], linewidth=2), showfliers=False)

        if bla == 0:
            ax.scatter(np.repeat(x[pat][bla], len(corr_vis[bla][0][:,pat])), corr_vis[bla][0][:,pat], color=colors[pat], label=pattern_category[pat])
        else:
            ax.scatter(np.repeat(x[pat][bla], len(corr_vis[bla][0][:,pat])), corr_vis[bla][0][:,pat], color=colors[pat])
    # ax.errorbar(x[pat], corr_vis_means[:,pat], yerr=corr_vis_std[:,pat], color=colors[pat], ecolor=colors[pat], fmt='o', markersize=20, capsize=10, capthick=5, elinewidth=5, barsabove=True, label=pattern_category[pat])
plt.xticks(x[2], my_xticks)
ax.set_xlim([-0.2, 11.0])
ax.set_ylim([-0.002, 0.05])
fig.legend(loc=(0.855, 0.47))
fig.tight_layout()
plt.savefig(os.path.join(plot_dir, 'completion_visible-part_correct.' + output_format))
plt.close()

#import pdb; pdb.set_trace()

######################################
# Qualitative examples plotted       #
######################################
# due to a bug (i forgot to call cuda.to_cpu before storing the results, some
# files might only be possible to open on a cuda-installed PC...


x_train = np.float32(np.load(training_data_file))

from chainer import cuda

num_timesteps = 90
input_dim = 3
given_part = 30
num_classes = 6

# plot final drawing only
# fileformat = '.pdf'
# traj_lengths_to_plot=[90]
# # for video animation
fileformat = '.pdf'

image_idx_start = 0 # required if different lengths should be plot for making a video
# traj_lengths_to_plot= np.concatenate((np.arange(num_timesteps), np.tile(90, (200,))))
traj_lengths_to_plot = [90]

figWidth = 50
# run_idx = [6,7,8]
run_idx = [0,1,2,3,4,5,6,7,8,9]


for curr_r in range(num_runs):
    for test_hyp_condition in range(len(test_hyp_all)):

        image_idx = image_idx_start
        for l in traj_lengths_to_plot:
            fig = plt.figure('Qualitative results', figsize=(figWidth,30)) #figsize=(10, 11.0))
            plt.rcParams.update({'font.size': 35, 'legend.fontsize': 30})
            curr_subplot=0
            for pat in range(num_patterns):
                for r in range(len(run_idx)):
                    input_traj_idx = run_idx[r]*num_classes+pat
                    print(str(run_idx[r]) + ", " + str(pat) + ", " + str(input_traj_idx))

                    ax = fig.add_subplot(num_patterns,len(run_idx),1 + curr_subplot)
                    # ax.set_xlabel('$x_0$')
                    # ax.set_ylabel('$x_1$')
                    ax.set_xlim([-0.9, 0.9])
                    ax.set_ylim([-0.9, 1])
                    # if run_idx[r] > 0:
                    plt.yticks([], [])
                    # if pat < 2:
                    plt.xticks([], [])

                    ax.plot(x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),0], x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),1], 'orange', linewidth = 5)
                    traj = cuda.to_cpu(results[test_hyp_condition][0][curr_r*num_runs+run_idx[r],pat].reshape((num_timesteps, input_dim)))
                    for t in range(1, l):
                        if int(np.round(traj[t,2])) == 1:
                            if t < given_part:
                                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
                            else:
                                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
                        else:
                            if t < given_part:
                                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)
                            else:
                                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
                    if r == 4:
                        # in the middle put the title
                        if pat == 0:
                            plt.title('FACE')
                        elif pat == 1:
                            plt.title('HOUSE')
                        elif pat == 2:
                            plt.title('CAR')
                        elif pat == 3:
                            plt.title('FLOWER')
                        elif pat == 4:
                            plt.title('HUMAN')
                        elif pat == 5:
                            plt.title('ROCKET')

                    curr_subplot += 1
            plt.tight_layout()
            plt.savefig(os.path.join(plot_dir, 'Qualitative-' + str(test_hyp_all[test_hyp_condition]) + "_run-" + dir_list[curr_r] + "_" + str(image_idx) + fileformat))
            image_idx += 1
            plt.close()
#
# # run_idx = [6,7,8]
# # run_idx = [0,1,2,3,4,5,6,7,8,9]
# image_idx = image_idx_start
# for l in traj_lengths_to_plot:
#     fig = plt.figure('Qualitative results', figsize=(figWidth, 11))
#     plt.rcParams.update({'font.size': 35, 'legend.fontsize': 30})
#     curr_subplot=0
#     for pat in range(results_normal.shape[0]):
#         for r in range(len(run_idx)):
#             input_traj_idx = run_idx[r]*num_classes+pat
#             ax = fig.add_subplot(3, len(run_idx),1 + curr_subplot)
#             # ax.set_xlabel('$x_0$')
#             # ax.set_ylabel('$x_1$')
#             ax.set_xlim([-0.9, 0.9])
#             ax.set_ylim([-0.9, 1])
#             # if run_idx[r] > 0:
#             plt.yticks([], [])
#             # if pat < 2:
#             plt.xticks([], [])
#             ax.plot(x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),0], x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),1], 'orange', linewidth = 5)
#             traj = cuda.to_cpu(results_normal[pat][run_idx[r]].reshape((num_timesteps, input_dim)))
#             for t in range(1, l):
#                 if int(np.round(traj[t,2])) == 1:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
#                 else:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
#             if r == 1:
#                 # in the middle put the title
#                 if pat == 0:
#                     plt.title('FACE')
#                 elif pat == 1:
#                     plt.title('HOUSE')
#                 elif pat == 2:
#                     plt.title('FLOWER')
#             curr_subplot += 1
#     plt.tight_layout()
#     plt.savefig(os.path.join(plot_dir, 'Qualitative-normal_' + str(image_idx) + fileformat))
#     image_idx += 1
#     plt.close()
#
# # run_idx = [6,7,8]
# # run_idx = [0,1,2,3,4,5,6,7,8,9]
# image_idx = image_idx_start
# for l in traj_lengths_to_plot:
#     fig = plt.figure('Qualitative results', figsize=(figWidth, 11))
#     plt.rcParams.update({'font.size': 35, 'legend.fontsize': 30})
#     curr_subplot=0
#     for pat in range(results_hypo_mod.shape[0]):
#         for r in range(len(run_idx)):
#             input_traj_idx = run_idx[r]*num_classes+pat
#             ax = fig.add_subplot(3,len(run_idx),1 + curr_subplot)
#             # ax.set_xlabel('$x_0$')
#             # ax.set_ylabel('$x_1$')
#             ax.set_xlim([-0.9, 0.9])
#             ax.set_ylim([-0.9, 1])
#             # if run_idx[r] > 0:
#             plt.yticks([], [])
#             # if pat < 2:
#             plt.xticks([], [])
#             ax.plot(x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),0], x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),1], 'orange', linewidth = 5)
#             traj = cuda.to_cpu(results_hypo_mod[pat][run_idx[r]].reshape((num_timesteps, input_dim)))
#             for t in range(1, l):
#                 if int(np.round(traj[t,2])) == 1:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
#                 else:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
#             if r == 1:
#                 # in the middle put the title
#                 if pat == 0:
#                     plt.title('FACE')
#                 elif pat == 1:
#                     plt.title('HOUSE')
#                 elif pat == 2:
#                     plt.title('FLOWER')
#             curr_subplot += 1
#     plt.tight_layout()
#     plt.savefig(os.path.join(plot_dir, 'Qualitative-hypo-mod_' + str(image_idx) + fileformat))
#     image_idx += 1
#     plt.close()
#
#
# # run_idx = [6,7,8]
# # run_idx = [0,1,2,3,4,5,6,7,8,9]
# image_idx = image_idx_start
# for l in traj_lengths_to_plot:
#     fig = plt.figure('Qualitative results', figsize=(figWidth,11))
#     plt.rcParams.update({'font.size': 35, 'legend.fontsize': 30})
#     curr_subplot=0
#     for pat in range(results_hypo.shape[0]):
#         for r in range(len(run_idx)):
#             input_traj_idx = run_idx[r]*num_classes+pat
#             ax = fig.add_subplot(3,len(run_idx),1 + curr_subplot)
#             # ax.set_xlabel('$x_0$')
#             # ax.set_ylabel('$x_1$')
#             ax.set_xlim([-0.9, 0.9])
#             ax.set_ylim([-0.9, 1])
#             # if run_idx[r] > 0:
#             plt.yticks([], [])
#             # if pat < 2:
#             plt.xticks([], [])
#             ax.plot(x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),0], x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),1], 'orange', linewidth = 5)
#             traj = cuda.to_cpu(results_hypo[pat][run_idx[r]].reshape((num_timesteps, input_dim)))
#             for t in range(1, l):
#                 if int(np.round(traj[t,2])) == 1:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
#                 else:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
#             if r == 1:
#                 # in the middle put the title
#                 if pat == 0:
#                     plt.title('FACE')
#                 elif pat == 1:
#                     plt.title('HOUSE')
#                 elif pat == 2:
#                     plt.title('FLOWER')
#             curr_subplot += 1
#     plt.tight_layout()
#     plt.savefig(os.path.join(plot_dir, 'Qualitative-hypo_' + str(image_idx) + fileformat))
#     image_idx += 1
#     plt.close()
#
#
#
# # run_idx = [6,7,8]
# # run_idx = [0,1,2,3,4,5,6,7,8,9]
# image_idx = image_idx_start
# for l in traj_lengths_to_plot:
#     fig = plt.figure('Qualitative results', figsize=(figWidth,11))
#     plt.rcParams.update({'font.size': 35, 'legend.fontsize': 30})
#     curr_subplot=0
#     for pat in range(results_hypo_extr.shape[0]):
#         for r in range(len(run_idx)):
#             input_traj_idx = run_idx[r]*num_classes+pat
#             ax = fig.add_subplot(3,len(run_idx),1 + curr_subplot)
#             # ax.set_xlabel('$x_0$')
#             # ax.set_ylabel('$x_1$')
#             ax.set_xlim([-0.9, 0.9])
#             ax.set_ylim([-0.9, 1])
#             # if run_idx[r] > 0:
#             plt.yticks([], [])
#             # if pat < 2:
#             plt.xticks([], [])
#             ax.plot(x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),0], x_train[input_traj_idx,:].reshape((-1,input_dim))[0:min(30,l),1], 'orange', linewidth = 5)
#             traj = cuda.to_cpu(results_hypo_extr[pat][run_idx[r]].reshape((num_timesteps, input_dim)))
#             for t in range(1, l):
#                 if int(np.round(traj[t,2])) == 1:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
#                 else:
#                     if t < given_part:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)
#                     else:
#                         ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
#             if r == 1:
#                 # in the middle put the title
#                 if pat == 0:
#                     plt.title('FACE')
#                 elif pat == 1:
#                     plt.title('HOUSE')
#                 elif pat == 2:
#                     plt.title('FLOWER')
#             curr_subplot += 1
#     plt.tight_layout()
#     plt.savefig(os.path.join(plot_dir, 'Qualitative-hypo-extr_' + str(image_idx) + fileformat))
#     image_idx += 1
#     plt.close()


######################################
# Plot training data                 #
######################################

"""
# Plot training data
train_data = np.load('/home/anja/repos/cognitivemirroring/ChainerRNN/data/drawings/multi-stroke/drawings-190215-faces-houses-flowers.npy')
num_timesteps = 90
input_dim = 3
given_part = 0
num_classes = 3
# 3rd dim == 1 means that this point is connected to the previous one, dim == 0 that not!

fig = plt.figure('Original training data', figsize=(30, 10.0))
plt.rcParams.update({'font.size': 55, 'legend.fontsize': 30})
ax = fig.add_subplot(131)
ax.set_xlabel('$x_0$')
ax.set_ylabel('$x_1$')
ax.set_xlim([-1, 1])
ax.set_ylim([-0.9, 1.1])
for i in range(0, train_data.shape[0], num_classes):
    for t in range(1, num_timesteps):
        traj = train_data[i,:].reshape((num_timesteps, input_dim))
        if int(np.round(traj[t,2])) == 1:
            if t < given_part:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 0.5)
            else:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 0.5)
        else:
            if t < given_part:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 0.5)
            else:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 0.5)
i=6
for t in range(1, num_timesteps):
    traj = train_data[i,:].reshape((num_timesteps, input_dim))
    if int(np.round(traj[t,2])) == 1:
        if t < given_part:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
        else:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
    else:
        if t < given_part:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
        else:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)

ax = fig.add_subplot(132)
ax.set_xlabel('$x_0$')
# ax.set_ylabel('$x_1$')
ax.set_xlim([-1, 1])
ax.set_ylim([-0.9, 1.1])
for i in range(1, train_data.shape[0], num_classes):
    for t in range(1, num_timesteps):
        traj = train_data[i,:].reshape((num_timesteps, input_dim))
        if int(np.round(traj[t,2])) == 1:
            if t < given_part:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 0.5)
            else:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 0.5)
        else:
            if t < given_part:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 0.5)
            else:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 0.5)
i=7
for t in range(1, num_timesteps):
    traj = train_data[i,:].reshape((num_timesteps, input_dim))
    if int(np.round(traj[t,2])) == 1:
        if t < given_part:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
        else:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
    else:
        if t < given_part:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
        else:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)
plt.yticks([], [])

# plt.title('Training data generated by human')
ax = fig.add_subplot(133)
ax.set_xlabel('$x_0$')
# ax.set_ylabel('$x_1$')
ax.set_xlim([-1, 1])
ax.set_ylim([-0.9, 1.1])
for i in range(2, train_data.shape[0], num_classes):
    for t in range(1, num_timesteps):
        traj = train_data[i,:].reshape((num_timesteps, input_dim))
        if int(np.round(traj[t,2])) == 1:
            if t < given_part:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 0.5)
            else:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 0.5)
        else:
            if t < given_part:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 0.5)
            else:
                ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 0.5)
i=8
for t in range(1, num_timesteps):
    traj = train_data[i,:].reshape((num_timesteps, input_dim))
    if int(np.round(traj[t,2])) == 1:
        if t < given_part:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
        else:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
    else:
        if t < given_part:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
        else:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)
plt.yticks([], [])

plt.tight_layout()
plt.savefig('original-training-data.pdf')
plt.close()
"""



######################################
# Plot training data                 #
######################################

"""
# Plot network results
from nets import load_network

network_path = '/home/anja/repos/cognitivemirroring/ChainerRNN/results/190221_faces-houses-flowers_ng07/trained_nets/2019-02-21_10-24_0669245'
network_file = 'network-epoch-21801.npz'

params, model = load_network(network_path, model_filename=network_file)
model.add_BI_variance = False

# res, resv, resm, u_h_history = model.generate(model.initial_states.W.array, num_timesteps, epsilon_disturbance = 0, additional_output='activations', external_signal_variance = 1)
res, resv, resm, pe, wpe = model.generate(model.initial_states.W.array, num_timesteps, external_input = np.float32(train_data[0:3,:]), epsilon_disturbance = 0)

fig = plt.figure('Network generation at 21800 epochs', figsize=(30, 10.0))
plt.rcParams.update({'font.size': 55, 'legend.fontsize': 30})
ax = fig.add_subplot(131)
ax.set_xlabel('$x_0$')
ax.set_ylabel('$x_1$')
ax.set_xlim([-1, 1])
ax.set_ylim([-0.9, 1.1])
i=0
for t in range(1, num_timesteps):
    traj = res[i,:].reshape((num_timesteps, input_dim))
    if int(np.round(traj[t,2])) == 1:
        if t < given_part:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
        else:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
    else:
        if t < given_part:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
        else:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)

ax = fig.add_subplot(132)
ax.set_xlabel('$x_0$')
# ax.set_ylabel('$x_1$')
ax.set_xlim([-1, 1])
ax.set_ylim([-0.9, 1.1])
i=1
for t in range(1, num_timesteps):
    traj = res[i,:].reshape((num_timesteps, input_dim))
    if int(np.round(traj[t,2])) == 1:
        if t < given_part:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
        else:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
    else:
        if t < given_part:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
        else:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)
# plt.title('Proactive network generation after 21800 epochs')
plt.yticks([], [])

ax = fig.add_subplot(133)
ax.set_xlabel('$x_0$')
# ax.set_ylabel('$x_1$')
ax.set_xlim([-1, 1])
ax.set_ylim([-0.9, 1.1])
i=2
for t in range(1, num_timesteps):
    traj = res[i,:].reshape((num_timesteps, input_dim))
    if int(np.round(traj[t,2])) == 1:
        if t < given_part:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'g', linewidth = 5)
        else:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 5)
    else:
        if t < given_part:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], '#11ff11', linewidth = 5)
        else:
            ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 5)
plt.yticks([], [])
plt.tight_layout()
plt.savefig(os.path.join(plot_dir, 'network-generation-21801.pdf'))
plt.close()
"""

######################################
# Plotting errors, not used currently#
######################################
"""
proact_err = np.load('/home/anja/repos/cognitivemirroring/ChainerRNN/results/190221_faces-houses-flowers_ng07/trained_nets/2019-02-21_10-24_0669245/history_generation_error_proactive.npy')
react_err = np.load('/home/anja/repos/cognitivemirroring/ChainerRNN/results/190221_faces-houses-flowers_ng07/trained_nets/2019-02-21_10-24_0669245/history_generation_error_reactive.npy')

proact_means = np.mean(np.concatenate((proact_err[0], proact_err[1], proact_err[2]), axis=0).reshape((3,-1)),axis=0)

fig = plt.figure('Network generation at 21800 epochs', figsize=(35, 10.0))
plt.rcParams.update({'font.size': 35, 'legend.fontsize': 30})
ax = fig.add_subplot(111)
# ax.set_xlabel('$x_0$')
# ax.set_ylabel('$x_1$')
# ax.set_xlim([-1, 1])
# ax.set_ylim([-0.9, 1.1])
plt.plot(np.arange(proact_means.shape[0]), proact_means)
plt.savefig(os.path.join(plot_dir, 'proact-error.pdf'))
plt.close()

react_means = np.mean(np.concatenate((react_err[0], react_err[1], react_err[2]), axis=0).reshape((3,-1)),axis=0)

fig = plt.figure('Network generation at 21800 epochs', figsize=(35, 10.0))
plt.rcParams.update({'font.size': 35, 'legend.fontsize': 30})
ax = fig.add_subplot(111)
# ax.set_xlabel('$x_0$')
# ax.set_ylabel('$x_1$')
# ax.set_xlim([-1, 1])
# ax.set_ylim([-0.9, 1.1])
plt.plot(np.arange(react_means.shape[0]), react_means)
plt.savefig(os.path.join(plot_dir, 'react-error.pdf'))
plt.close()
"""


######################################
# Bayesian inference for ICDL19_Anja #
######################################

"""
import population_coding as pop

# Bayesian inference for ICDL paper

# # For ICDL19_Anja
# hyper
pred_var = 0.001
# # normal
# pred_var = 0.005
# # hypo
# pred_var = 0.02


# # For ICDL19_Daniel:
# # early learning stage
# pred_var = 0.1
# input_var = 0.005
# # # later learning stage
# # pred_var = 0.015
# # input_var = 0.005
# # # fog
# # pred_var = 0.015
# # input_var = 0.05

pred_mean = 0.3
input_mean = 0.7

sigma = np.sqrt((input_var * pred_var) / (input_var + pred_var))
mu = np.power(sigma, 2) * (((pred_mean / pred_var) + (input_mean / input_var)))

input_pop = pop.transform_to_population_coding(np.reshape(input_mean, (1,1)), 1000, np.reshape(input_var,(1,1)), -1.0, 1.0)
prior_pop = pop.transform_to_population_coding(np.reshape(pred_mean, (1,1)), 1000, np.reshape(pred_var,(1,1)), -1.0, 1.0)
posterior_pop = pop.transform_to_population_coding(np.reshape(mu, (1,1)), 1000, np.reshape(sigma ** 2,(1,1)), -1.0, 1.0)

output = np.random.normal(mu, sigma, 1)

print(output)

value_range = np.reshape(np.linspace(-1.0, 1.0, 1000), (1,1000))

fig = plt.figure('Bayesian Inference', figsize = (16.0, 10.0))

plt.rcParams.update({'font.size': 40, 'legend.fontsize': 40})
plt.rc('xtick', labelsize=40)
plt.rc('ytick', labelsize=40)

ax = fig.add_subplot(111)
ax.set_xlabel('position x')
ax.set_ylabel('probability in %')

#ax.set_title('Early learning stage')
# ax.set_title('Medium learning stage')
# ax.set_title('Late learning stage')
# ax.set_title('After learning, environmental uncertainty')
ax.plot(value_range[0, :], input_pop[0, :], 'r', label='sensory input', linewidth=7.0)
ax.plot(value_range[0, :], prior_pop[0, :], 'b', label='prior', linewidth=7.0)
ax.plot(value_range[0, :], posterior_pop[0, :], 'g', label='posterior', linewidth=7.0)

ax.set_xlim([0, 1])
ax.set_ylim([0, 7])
ax.legend()

#plt.show()
plt.tight_layout()


# # For ICDL19_Anja
 plt.savefig('BI_hyper.pdf')
# plt.savefig('BI_normal.pdf')
# plt.savefig('BI_hypo.pdf')

# # For ICDL19_Daniel
# plt.savefig('BI_early.pdf')
# # plt.savefig('BI_later.pdf')
# # plt.savefig('BI_fog.pdf')

plt.close()
"""

##########################
# Plotting training data #
##########################

"""
x_train = np.float32(np.load('/home/anja/repos/cognitivemirroring/ChainerRNN/data/drawings/multi-stroke/drawings-190215-faces-houses-flowers.npy'))

# # for video animation
input_dim = 3
figWidth = 10
num_timesteps = 90
fileformat = '.png'
# traj_lengths_to_plot= np.arange(num_timesteps)
traj_lengths_to_plot= np.concatenate((np.arange(90), np.tile(90, (200,))))

image_idx = 0
for l in traj_lengths_to_plot:
    fig = plt.figure('Training data', figsize=(10,4)) #figsize=(10, 11.0))
    plt.rcParams.update({'font.size': 35, 'legend.fontsize': 30})
    curr_subplot=0
    for pat in range(0,3):

        ax = fig.add_subplot(1,3,1 + curr_subplot)
        # ax.set_xlabel('$x_0$')
        # ax.set_ylabel('$x_1$')
        ax.set_xlim([-0.9, 0.9])
        ax.set_ylim([-0.9, 1])
        # if run_idx[r] > 0:
        plt.yticks([], [])
        # if pat < 2:
        plt.xticks([], [])
        # ax.plot(x_train[pat,:].reshape((-1,input_dim))[0:30,0], x_train[pat,:].reshape((-1,input_dim))[0:30,1], 'orange', linewidth = 5)
        for pat2 in range(pat, 30, 3):
            traj = x_train[pat2,:].reshape((num_timesteps, input_dim))
            for t in range(1, l):
                if int(np.round(traj[t,2])) == 1:
                    ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'k', linewidth = 1)
                else:
                    ax.plot(traj[t-1:t+1,0], traj[t-1:t+1,1], 'lightgray', linewidth = 1)


        if pat == 0:
            plt.title('FACE')
        elif pat == 1:
            plt.title('HOUSE')
        elif pat == 2:
            plt.title('FLOWER')
        curr_subplot += 1
    plt.tight_layout()
    plt.savefig(os.path.join(plot_dir, 'Training-data_' + str(image_idx) + fileformat))
    image_idx += 1
    plt.close()

"""
